name: "Mirror Docker Images to Aliyun ACR"
description: "Mirror Docker images to Alibaba Cloud Container Registry via ECS internal network"

inputs:
  # Image source options (use ONE of the following three methods):
  # Method 1: Single image - provide source_image and target_image
  # Method 2: Inline config - provide config_content (YAML string)
  # Method 3: Config file - provide config_file path

  # Method 1: Single image mirroring
  source_image:
    description: "Source image to mirror (e.g. ghcr.io/org/image:tag). Use with target_image."
    required: false
  target_image:
    description: "Target image(s) in ACR. Supports multiple targets separated by newlines or commas. Use with source_image."
    required: false

  # Method 2: Inline config content
  config_content:
    description: "YAML config content as string. Alternative to config_file."
    required: false

  # Method 3: Config file path
  config_file:
    description: "Path to the YAML config file containing mirror definitions"
    required: false

  # Registry credentials (JSON format)
  # Format: {"registry_host": {"username": "xxx", "password": "xxx"}, ...}
  # Example: {"ghcr.io": {"username": "user", "password": "token"}, "docker.io": {"username": "user", "password": "pass"}}
  registry_credentials:
    description: "JSON object containing registry credentials. Keys are registry hosts, values are {username, password} objects."
    required: false
    default: "{}"

  # Aliyun ECS credentials
  ali_access_key:
    description: "Alibaba Cloud Access Key ID"
    required: true
  ali_secret_key:
    description: "Alibaba Cloud Access Key Secret"
    required: true
  ali_region:
    description: "Alibaba Cloud region ID (e.g. cn-shenzhen)"
    required: true
    default: "cn-shenzhen"

  # ECS instance configuration
  vswitch_id:
    description: "Existing VSwitch ID for the ECS instance"
    required: true
  availability_zone:
    description: "Availability zone for the ECS instance"
    required: true
  security_group_id:
    description: "Security group ID for the ECS instance"
    required: true
  image_id:
    description: "Image ID for the ECS instance"
    required: false
    default: "ubuntu_24_04_x64_20G_alibase_20251102.vhd"
  instance_type:
    description: "ECS instance type"
    required: false
    default: "ecs.c7a.large"
  system_disk_size:
    description: "System disk size in GB"
    required: false
    default: "40"
  spot_strategy:
    description: "Spot strategy (NoSpot/SpotWithPriceLimit/SpotAsPriceGo)"
    required: false
    default: "SpotAsPriceGo"
  key_pair_name:
    description: "SSH key pair name for ECS (required if using key-based auth)"
    required: false
  ssh_private_key:
    description: "SSH private key content for connecting to ECS (required if using key-based auth)"
    required: false
  instance_password:
    description: "ECS instance password for SSH auth (alternative to key-based auth)"
    required: false

  # Optional settings
  post_ssh_wait_seconds:
    description: "Extra seconds to wait after SSH becomes available"
    required: false
    default: "30"
  runner_name_prefix:
    description: "Prefix for ECS instance name"
    required: false
    default: "mirror-acr"
  scp_timeout:
    description: "SCP transfer timeout"
    required: false
    default: "30m"
  ssh_timeout:
    description: "SSH command timeout"
    required: false
    default: "30m"
  ecs_auto_release_hours:
    description: "Hours until ECS instance auto-release (safety mechanism if workflow fails)"
    required: false
    default: "1"

outputs:
  mirrored_images:
    description: "JSON array of successfully mirrored images"
    value: ${{ steps.summary.outputs.mirrored_images }}
  failed_images:
    description: "JSON array of failed images"
    value: ${{ steps.summary.outputs.failed_images }}

runs:
  using: composite
  steps:
    # Step 0: Install deps
    - name: Install yq
      uses: dcarbone/install-yq-action@v1
    - name: Install jq
      uses: dcarbone/install-jq-action@v3

    # Step 1: Login to registries and pull images
    - name: Login to registries and pull images
      id: pull
      shell: bash
      env:
        SOURCE_IMAGE: ${{ inputs.source_image }}
        TARGET_IMAGE: ${{ inputs.target_image }}
        CONFIG_CONTENT: ${{ inputs.config_content }}
        CONFIG_FILE: ${{ inputs.config_file }}
        REGISTRY_CREDENTIALS: ${{ inputs.registry_credentials }}
      run: |
        set -euo pipefail

        # Determine config source and create effective config file
        EFFECTIVE_CONFIG="${GITHUB_WORKSPACE}/.mirror-config-effective.yaml"

        if [ -n "$SOURCE_IMAGE" ] && [ -n "$TARGET_IMAGE" ]; then
          # Method 1: Single/Multi image mode - one source to one or more targets
          echo "=== Using single image mode ==="
          echo "Source: $SOURCE_IMAGE"

          # Parse targets (support comma or newline separated)
          # Replace commas with newlines, then filter empty lines
          targets_list=$(echo "$TARGET_IMAGE" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')

          echo "Targets:"
          echo "$targets_list"

          # Generate config with targets array
          {
            echo "mirror:"
            echo "  - source: \"$SOURCE_IMAGE\""
            echo "    targets:"
            while IFS= read -r t; do
              echo "      - \"$t\""
            done <<< "$targets_list"
          } > "$EFFECTIVE_CONFIG"
        elif [ -n "$CONFIG_CONTENT" ]; then
          # Method 2: Inline config content
          echo "=== Using inline config content ==="
          echo "$CONFIG_CONTENT" > "$EFFECTIVE_CONFIG"
        elif [ -n "$CONFIG_FILE" ] && [ -f "$CONFIG_FILE" ]; then
          # Method 3: Config file
          echo "=== Using config file: $CONFIG_FILE ==="
          cp "$CONFIG_FILE" "$EFFECTIVE_CONFIG"
        else
          echo "::error::No valid config provided. Use one of: (1) source_image + target_image, (2) config_content, (3) config_file"
          exit 1
        fi

        echo "=== Effective config ==="
        cat "$EFFECTIVE_CONFIG"

        # Create temp directory for tar files
        IMAGES_DIR="${GITHUB_WORKSPACE}/.mirror-images"
        mkdir -p "$IMAGES_DIR"
        echo "images_dir=$IMAGES_DIR" >> "$GITHUB_OUTPUT"

        # Track logged in registries to avoid duplicate logins
        declare -A LOGGED_IN_REGISTRIES

        # Function to extract registry host from image name
        get_registry_host() {
          local image="$1"
          # Check if image contains a registry host (has a dot before the first slash)
          if [[ "$image" =~ ^([^/]+\.[^/]+)/ ]]; then
            echo "${BASH_REMATCH[1]}"
          elif [[ "$image" =~ ^([^/]+)/ ]] && [[ "${BASH_REMATCH[1]}" == *"."* || "${BASH_REMATCH[1]}" == *":"* ]]; then
            echo "${BASH_REMATCH[1]}"
          else
            # Default to docker.io for images like "nginx:latest" or "library/nginx"
            echo "docker.io"
          fi
        }

        # Function to convert ACR internal (VPC) address to public address for image existence check
        # Internal: crpi-xxx-vpc.cn-shenzhen.personal.cr.aliyuncs.com -> Public: crpi-xxx.cn-shenzhen.personal.cr.aliyuncs.com
        # Internal: registry-vpc.cn-hongkong.aliyuncs.com -> Public: registry.cn-hongkong.aliyuncs.com
        convert_vpc_to_public() {
          local image="$1"
          # Only convert if it's an aliyuncs.com image with -vpc
          if [[ "$image" == *".aliyuncs.com"* ]] && [[ "$image" == *"-vpc."* ]]; then
            echo "$image" | sed 's/-vpc\.\([^/]*\.aliyuncs\.com\)/.\1/'
          else
            echo "$image"
          fi
        }

        # Function to login to a registry (exact match only)
        login_to_registry() {
          local registry="$1"

          # Skip if already logged in
          if [[ -n "${LOGGED_IN_REGISTRIES[$registry]:-}" ]]; then
            echo "Already logged in to $registry"
            return 0
          fi

          # Check if credentials exist for this registry (exact match)
          local creds
          creds=$(echo "$REGISTRY_CREDENTIALS" | jq -r --arg reg "$registry" '.[$reg] // empty')

          if [ -n "$creds" ]; then
            local username password
            username=$(echo "$creds" | jq -r '.username')
            password=$(echo "$creds" | jq -r '.password')

            if [ -n "$username" ] && [ -n "$password" ] && [ "$username" != "null" ] && [ "$password" != "null" ]; then
              echo "Logging in to registry: $registry"
              if [ "$registry" = "docker.io" ]; then
                echo "$password" | docker login -u "$username" --password-stdin
              else
                echo "$password" | docker login "$registry" -u "$username" --password-stdin
              fi
              LOGGED_IN_REGISTRIES[$registry]=1
              echo "Successfully logged in to $registry"
              return 0
            fi
          fi

          echo "No credentials found for $registry, assuming public access"
          return 0
        }

        # Parse mirror entries and pull images
        SOURCES=()
        TARGETS=()
        TAR_FILES=()
        TARGET_REGISTRIES=()

        entry_count=$(yq '.mirror | length' "$EFFECTIVE_CONFIG")
        echo "Found $entry_count mirror entries"

        # Track which sources we've already pulled (to avoid duplicate pulls)
        declare -A PULLED_SOURCES

        for ((i=0; i<entry_count; i++)); do
          source=$(yq ".mirror[$i].source" "$EFFECTIVE_CONFIG")

          # Support both 'target' (single string) and 'targets' (array) formats
          # Check if 'targets' array exists
          targets_count=$(yq ".mirror[$i].targets | length" "$EFFECTIVE_CONFIG" 2>/dev/null || echo "0")

          if [ "$targets_count" != "0" ] && [ "$targets_count" != "null" ]; then
            # New format: targets array
            targets_array=()
            for ((j=0; j<targets_count; j++)); do
              t=$(yq ".mirror[$i].targets[$j]" "$EFFECTIVE_CONFIG")
              targets_array+=("$t")
            done
          else
            # Old format: single target
            single_target=$(yq ".mirror[$i].target" "$EFFECTIVE_CONFIG")
            targets_array=("$single_target")
          fi

          echo ""
          echo "=== Processing entry $((i+1))/$entry_count ==="
          echo "Source: $source"
          echo "Targets (${#targets_array[@]}): ${targets_array[*]}"

          # Check which targets need mirroring
          targets_to_mirror=()
          for target in "${targets_array[@]}"; do
            # Track target registry for later
            target_registry=$(get_registry_host "$target")
            if [[ ! " ${TARGET_REGISTRIES[*]:-} " =~ " ${target_registry} " ]]; then
              TARGET_REGISTRIES+=("$target_registry")
            fi

            # Check if target image already exists (using public address for ACR)
            public_target=$(convert_vpc_to_public "$target")
            public_target_registry=$(get_registry_host "$public_target")

            echo "Checking if target exists: $public_target"
            login_to_registry "$public_target_registry"

            if docker manifest inspect "$public_target" > /dev/null 2>&1; then
              echo "  ✓ Already exists, skipping: $target"
            else
              echo "  ✗ Not found, will mirror: $target"
              targets_to_mirror+=("$target")
            fi
          done

          # Skip if all targets already exist
          if [ ${#targets_to_mirror[@]} -eq 0 ]; then
            echo "All targets already exist for source: $source"
            continue
          fi

          # Pull source image only once
          safe_name=$(echo "$source" | sed 's/[^a-zA-Z0-9._-]/_/g')
          tar_file="${IMAGES_DIR}/${safe_name}.tar"

          if [[ -z "${PULLED_SOURCES[$source]:-}" ]]; then
            source_registry=$(get_registry_host "$source")
            echo "Source registry: $source_registry"
            login_to_registry "$source_registry"

            echo "Pulling image: $source"
            docker pull "$source"

            echo "Saving image to: $tar_file"
            docker save -o "$tar_file" "$source"
            echo "Saved: $(ls -lh "$tar_file")"

            PULLED_SOURCES[$source]="$tar_file"
          else
            echo "Source already pulled: $source"
            tar_file="${PULLED_SOURCES[$source]}"
          fi

          # Add each target that needs mirroring
          for target in "${targets_to_mirror[@]}"; do
            SOURCES+=("$source")
            TARGETS+=("$target")
            TAR_FILES+=("$tar_file")
            echo "Queued for mirror: $source -> $target"
          done
        done

        # Store arrays as JSON for later steps
        echo "sources=$(printf '%s\n' "${SOURCES[@]}" | jq -R . | jq -sc .)" >> "$GITHUB_OUTPUT"
        echo "targets=$(printf '%s\n' "${TARGETS[@]}" | jq -R . | jq -sc .)" >> "$GITHUB_OUTPUT"
        echo "tar_files=$(printf '%s\n' "${TAR_FILES[@]}" | jq -R . | jq -sc .)" >> "$GITHUB_OUTPUT"
        echo "target_registries=$(printf '%s\n' "${TARGET_REGISTRIES[@]}" | jq -R . | jq -sc .)" >> "$GITHUB_OUTPUT"
        echo "entry_count=$entry_count" >> "$GITHUB_OUTPUT"

        # Check if there are images to mirror
        images_to_mirror=${#SOURCES[@]}
        if [ "$images_to_mirror" -gt 0 ]; then
          echo "has_images=true" >> "$GITHUB_OUTPUT"
        else
          echo "has_images=false" >> "$GITHUB_OUTPUT"
        fi
        echo "images_to_mirror=$images_to_mirror" >> "$GITHUB_OUTPUT"

        echo ""
        echo "=== All images pulled and saved ==="
        echo "Images to mirror: $images_to_mirror"
        ls -lh "$IMAGES_DIR"
        echo ""
        if [ "$images_to_mirror" -eq 0 ]; then
          echo "✓ All images already exist in target registry, skipping ECS provisioning"
        else
          echo "Target registries that will need login: ${TARGET_REGISTRIES[*]}"
        fi

    # Step 2: Calculate auto release time for ECS safety
    - name: Calculate ECS auto release time
      id: auto_release
      if: ${{ steps.pull.outputs.has_images == 'true' }}
      shell: bash
      env:
        AUTO_RELEASE_HOURS: ${{ inputs.ecs_auto_release_hours }}
      run: |
        # Calculate auto release time: current time + N hours in RFC3339 format
        auto_release_time=$(date -u -d "+${AUTO_RELEASE_HOURS} hour" '+%Y-%m-%dT%H:%M:%SZ')
        echo "auto_release_time=$auto_release_time" >> "$GITHUB_OUTPUT"
        echo "ECS auto release time: $auto_release_time (${AUTO_RELEASE_HOURS}h from now)"

    # Step 3: Provision Aliyun ECS (skip if no images to mirror)
    - name: Provision Aliyun ECS
      id: provision
      if: ${{ steps.pull.outputs.has_images == 'true' }}
      uses: repotea-workspace/kangumi/github-actions/ecs-github-runner@main
      with:
        mode: start
        register_runner: "false"
        ali_access_key: ${{ inputs.ali_access_key }}
        ali_secret_key: ${{ inputs.ali_secret_key }}
        ali_region: ${{ inputs.ali_region }}
        vswitch_id: ${{ inputs.vswitch_id }}
        availability_zone: ${{ inputs.availability_zone }}
        security_group_id: ${{ inputs.security_group_id }}
        image_id: ${{ inputs.image_id }}
        ali_ecs_name: ${{ inputs.runner_name_prefix }}-${{ github.run_id }}-${{ github.run_attempt }}
        ali_ecs_instance_type: ${{ inputs.instance_type }}
        host_name: ${{ inputs.runner_name_prefix }}-${{ github.run_id }}-${{ github.run_attempt }}
        system_disk_size: ${{ inputs.system_disk_size }}
        key_pair_name: ${{ inputs.key_pair_name }}
        instance_password: ${{ inputs.instance_password }}
        spot_strategy: ${{ inputs.spot_strategy }}
        auto_release_time: ${{ steps.auto_release.outputs.auto_release_time }}
        post_ssh_wait_seconds: ${{ inputs.post_ssh_wait_seconds }}
        custom_user_data: |
          # Update package manager
          apt-get update
          # Add Docker package source
          apt-get -y install apt-transport-https ca-certificates curl software-properties-common jq
          curl -fsSL http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu/gpg | apt-key add -
          add-apt-repository -y "deb [arch=$(dpkg --print-architecture)] http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"
          # Install Docker
          apt-get -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

          systemctl start docker
          systemctl enable docker

    # Step 4: Upload tar files to ECS via SCP (skip if no images to mirror)
    - name: Upload images to ECS
      if: ${{ steps.pull.outputs.has_images == 'true' }}
      uses: appleboy/scp-action@v1
      with:
        host: ${{ steps.provision.outputs.public-ip }}
        username: root
        key: ${{ inputs.ssh_private_key }}
        password: ${{ inputs.instance_password }}
        timeout: ${{ inputs.scp_timeout }}
        source: ".mirror-images/*.tar"
        target: /tmp/mirror-images/
        strip_components: 1
        debug: "true"

    # Step 5: Execute docker load, tag, and push on ECS (skip if no images to mirror)
    - name: Load, tag and push images on ECS
      id: push
      if: ${{ steps.pull.outputs.has_images == 'true' }}
      uses: appleboy/ssh-action@v1
      env:
        REGISTRY_CREDENTIALS: ${{ inputs.registry_credentials }}
        SOURCES_JSON: ${{ steps.pull.outputs.sources }}
        TARGETS_JSON: ${{ steps.pull.outputs.targets }}
        TARGET_REGISTRIES_JSON: ${{ steps.pull.outputs.target_registries }}
      with:
        host: ${{ steps.provision.outputs.public-ip }}
        username: root
        key: ${{ inputs.ssh_private_key }}
        password: ${{ inputs.instance_password }}
        timeout: ${{ inputs.ssh_timeout }}
        envs: REGISTRY_CREDENTIALS,SOURCES_JSON,TARGETS_JSON,TARGET_REGISTRIES_JSON
        script: |
          set -ex

          echo "=== Docker Info ==="
          docker version

          # Track logged in registries
          declare -A LOGGED_IN_REGISTRIES

          # Login to all target registries
          echo "=== Login to target registries ==="
          target_registries=$(echo "$TARGET_REGISTRIES_JSON" | jq -r '.[]')
          for registry in $target_registries; do
            if [[ -n "${LOGGED_IN_REGISTRIES[$registry]:-}" ]]; then
              continue
            fi

            creds=$(echo "$REGISTRY_CREDENTIALS" | jq -r --arg reg "$registry" '.[$reg] // empty')
            if [ -n "$creds" ]; then
              username=$(echo "$creds" | jq -r '.username')
              password=$(echo "$creds" | jq -r '.password')

              if [ -n "$username" ] && [ -n "$password" ] && [ "$username" != "null" ] && [ "$password" != "null" ]; then
                echo "Logging in to registry: $registry"
                if [ "$registry" = "docker.io" ]; then
                  echo "$password" | docker login -u "$username" --password-stdin
                else
                  echo "$password" | docker login "$registry" -u "$username" --password-stdin
                fi
                LOGGED_IN_REGISTRIES[$registry]=1
                echo "Successfully logged in to $registry"
              else
                echo "::warning::No valid credentials for $registry"
              fi
            else
              echo "::warning::No credentials found for $registry"
            fi
          done

          echo "=== List uploaded tar files ==="
          ls -lh /tmp/mirror-images/

          echo "=== Processing images ==="

          # Parse JSON arrays
          sources=$(echo "$SOURCES_JSON" | jq -r '.[]')
          targets=$(echo "$TARGETS_JSON" | jq -r '.[]')

          # Convert to arrays
          readarray -t source_arr <<< "$sources"
          readarray -t target_arr <<< "$targets"

          # Track loaded sources to avoid duplicate loads
          declare -A LOADED_SOURCES

          # Count how many times each source is used (for cleanup decision)
          declare -A SOURCE_USAGE_COUNT
          declare -A SOURCE_CURRENT_COUNT
          for src in "${source_arr[@]}"; do
            SOURCE_USAGE_COUNT[$src]=$((${SOURCE_USAGE_COUNT[$src]:-0} + 1))
            SOURCE_CURRENT_COUNT[$src]=0
          done

          # Process each image
          for ((i=0; i<${#source_arr[@]}; i++)); do
            source="${source_arr[$i]}"
            target="${target_arr[$i]}"

            # Increment current count for this source
            SOURCE_CURRENT_COUNT[$source]=$((${SOURCE_CURRENT_COUNT[$source]} + 1))
            is_last_use=false
            if [ "${SOURCE_CURRENT_COUNT[$source]}" -eq "${SOURCE_USAGE_COUNT[$source]}" ]; then
              is_last_use=true
            fi

            echo ""
            echo "=== Image $((i+1))/${#source_arr[@]} ==="
            echo "Source: $source"
            echo "Target: $target"
            echo "Usage: ${SOURCE_CURRENT_COUNT[$source]}/${SOURCE_USAGE_COUNT[$source]} (last=$is_last_use)"

            # Double-check if target image already exists in registry
            echo "Checking if target image already exists..."
            if docker manifest inspect "$target" > /dev/null 2>&1; then
              echo "Image already exists in target registry, skipping: $target"
              # Still need to cleanup if this is the last use
              if [ "$is_last_use" = true ]; then
                safe_name=$(echo "$source" | sed 's/[^a-zA-Z0-9._-]/_/g')
                docker rmi "$source" 2>/dev/null || true
                rm -f "/tmp/mirror-images/${safe_name}.tar"
                echo "Cleaned up source image (last use)"
              fi
              continue
            fi
            echo "Image not found in target registry, proceeding with mirror..."

            # Find the tar file
            safe_name=$(echo "$source" | sed 's/[^a-zA-Z0-9._-]/_/g')
            tar_file="/tmp/mirror-images/${safe_name}.tar"

            # Load image only if not already loaded
            if [[ -z "${LOADED_SOURCES[$source]:-}" ]]; then
              if [ ! -f "$tar_file" ]; then
                echo "::warning::Tar file not found: $tar_file"
                continue
              fi

              echo "Loading image from: $tar_file"
              docker load -i "$tar_file"
              LOADED_SOURCES[$source]=1
            else
              echo "Image already loaded: $source"
            fi

            echo "Tagging: $source -> $target"
            docker tag "$source" "$target"

            echo "Pushing: $target"
            docker push "$target"

            echo "Successfully mirrored: $target"

            # Cleanup target image immediately to save space
            docker rmi "$target" 2>/dev/null || true

            # Only cleanup source image and tar file on last use
            if [ "$is_last_use" = true ]; then
              echo "Last use of source, cleaning up..."
              docker rmi "$source" 2>/dev/null || true
              rm -f "$tar_file"
            fi
          done

          echo ""
          echo "=== All images processed ==="

    # Step 6: Cleanup - Destroy ECS instance (only if it was provisioned)
    - name: Destroy ECS instance
      if: ${{ always() && steps.pull.outputs.has_images == 'true' }}
      uses: repotea-workspace/kangumi/github-actions/ecs-github-runner@main
      with:
        mode: destroy
        register_runner: "false"
        ali_access_key: ${{ inputs.ali_access_key }}
        ali_secret_key: ${{ inputs.ali_secret_key }}
        ali_region: ${{ inputs.ali_region }}
        vswitch_id: ${{ inputs.vswitch_id }}
        availability_zone: ${{ inputs.availability_zone }}
        security_group_id: ${{ inputs.security_group_id }}
        image_id: ${{ inputs.image_id }}

    # Step 7: Summary
    - name: Generate summary
      id: summary
      if: always()
      shell: bash
      env:
        SOURCES_JSON: ${{ steps.pull.outputs.sources }}
        TARGETS_JSON: ${{ steps.pull.outputs.targets }}
        HAS_IMAGES: ${{ steps.pull.outputs.has_images }}
        IMAGES_TO_MIRROR: ${{ steps.pull.outputs.images_to_mirror }}
      run: |
        echo "=== Mirror Summary ===" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_IMAGES" != "true" ]; then
          echo "✅ **No images needed to be mirrored** - all target images already exist." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "mirrored_images=[]" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "**Images mirrored: $IMAGES_TO_MIRROR**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Source | Target |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY

        sources=$(echo "$SOURCES_JSON" | jq -r '.[]' 2>/dev/null || echo "")
        targets=$(echo "$TARGETS_JSON" | jq -r '.[]' 2>/dev/null || echo "")

        if [ -n "$sources" ] && [ -n "$targets" ]; then
          readarray -t source_arr <<< "$sources"
          readarray -t target_arr <<< "$targets"

          for ((i=0; i<${#source_arr[@]}; i++)); do
            echo "| \`${source_arr[$i]}\` | \`${target_arr[$i]}\` |" >> $GITHUB_STEP_SUMMARY
          done
        fi

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "mirrored_images=$TARGETS_JSON" >> "$GITHUB_OUTPUT"

    # Step 8: Cleanup temporary files (always run to avoid polluting the workspace)
    - name: Cleanup temporary files
      if: always()
      shell: bash
      run: |
        echo "=== Cleaning up temporary files ==="
        rm -rf "${GITHUB_WORKSPACE}/.mirror-config-effective.yaml" || true
        rm -rf "${GITHUB_WORKSPACE}/.mirror-images" || true
        echo "✓ Cleanup complete"
