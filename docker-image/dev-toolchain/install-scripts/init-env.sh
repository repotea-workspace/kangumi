#!/usr/bin/env bash

set -euo pipefail

ENV_SCRIPT="/etc/profile.d/99-dev-tools-env.sh"

echo "[init-env] Starting environment initialization..."
echo "[init-env] CUSTOM_HOSTNAME=${CUSTOM_HOSTNAME:-<not set>}"
echo "[init-env] DOCKER_HOST=${DOCKER_HOST:-<not set>}"

# Create env script if it doesn't exist
if [ ! -f "${ENV_SCRIPT}" ]; then
  echo "[init-env] Creating ${ENV_SCRIPT}..."
  cat > "${ENV_SCRIPT}" << 'EOF'
#!/bin/bash
# Dev Tools Environment Configuration
# Auto-generated by dev-toolchain install scripts

EOF
  chmod +x "${ENV_SCRIPT}"
  echo "[init-env] Created ${ENV_SCRIPT}"
else
  echo "[init-env] ${ENV_SCRIPT} already exists"
fi

# Set custom hostname in prompt if CUSTOM_HOSTNAME env var is set
# This is needed in hostNetwork mode where pod hostname is the node hostname
# We use PS1 to display the desired hostname instead
if [ -n "${CUSTOM_HOSTNAME:-}" ]; then
  echo "[init-env] Configuring custom hostname: ${CUSTOM_HOSTNAME}"
  # Check if PS1 customization is already in the file
  if ! grep -qF "export CUSTOM_HOSTNAME=" "${ENV_SCRIPT}" 2>/dev/null; then
    cat >> "${ENV_SCRIPT}" << EOF

# Custom Hostname for Prompt
export CUSTOM_HOSTNAME="${CUSTOM_HOSTNAME}"
export PS1='\${debian_chroot:+(\$debian_chroot)}\u@\${CUSTOM_HOSTNAME}:\w\$ '
EOF
    echo "[init-env] Added CUSTOM_HOSTNAME to env script"
  else
    echo "[init-env] CUSTOM_HOSTNAME already configured"
  fi
else
  echo "[init-env] CUSTOM_HOSTNAME not set, skipping hostname configuration"
fi

# Export DOCKER_HOST if set (from Kubernetes env vars)
if [ -n "${DOCKER_HOST:-}" ]; then
  echo "[init-env] Configuring DOCKER_HOST: ${DOCKER_HOST}"
  # Check if DOCKER_HOST is already in the file
  if ! grep -qF "export DOCKER_HOST=" "${ENV_SCRIPT}" 2>/dev/null; then
    cat >> "${ENV_SCRIPT}" << EOF

# Docker Client Configuration
export DOCKER_HOST="${DOCKER_HOST}"
EOF
    echo "[init-env] Added DOCKER_HOST to env script"
  else
    echo "[init-env] DOCKER_HOST already configured"
  fi
else
  echo "[init-env] DOCKER_HOST not set, skipping docker configuration"
fi

# Export Homebrew environment variables
# These are set in Dockerfile ENV, we read them from current environment and persist to config file
# This ensures s6-overlay doesn't clear them and shell sessions can load them
echo "[init-env] Configuring Homebrew environment variables..."
if ! grep -qF "# Homebrew Environment" "${ENV_SCRIPT}" 2>/dev/null; then
  # Read from environment (set by Dockerfile ENV)
  # If not set, something is wrong with the image build
  if [ -z "${HOMEBREW_PREFIX:-}" ]; then
    echo "[init-env] WARNING: HOMEBREW_PREFIX not set in environment, using default"
  fi

  cat >> "${ENV_SCRIPT}" << EOF

# Homebrew Environment
# These values are inherited from Dockerfile ENV and persisted here for shell sessions
export HOMEBREW_PREFIX="${HOMEBREW_PREFIX}"
export HOMEBREW_CELLAR="${HOMEBREW_CELLAR}"
export HOMEBREW_REPOSITORY="${HOMEBREW_REPOSITORY}"
export HOMEBREW_ALLOW_ROOT=${HOMEBREW_ALLOW_ROOT}
export HOMEBREW_NO_ENV_HINTS=${HOMEBREW_NO_ENV_HINTS}
export HOMEBREW_NO_AUTO_UPDATE=${HOMEBREW_NO_AUTO_UPDATE}
export HOMEBREW_NO_INSTALL_FROM_API=${HOMEBREW_NO_INSTALL_FROM_API}
EOF
  echo "[init-env] Added Homebrew environment variables to env script"
  echo "[init-env]   HOMEBREW_PREFIX=${HOMEBREW_PREFIX}"
else
  echo "[init-env] Homebrew environment already configured"
fi

# Display final env script content for debugging
echo "[init-env] Final ${ENV_SCRIPT} content:"
cat "${ENV_SCRIPT}"
echo "[init-env] Environment initialization completed successfully"
