#!/usr/bin/env bash

set -euo pipefail

ENV_SCRIPT="/etc/profile.d/99-dev-tools-env.sh"

echo "[init-env] Starting environment initialization..."
echo "[init-env] CUSTOM_HOSTNAME=${CUSTOM_HOSTNAME:-<not set>}"
echo "[init-env] DOCKER_HOST=${DOCKER_HOST:-<not set>}"

# Create env script if it doesn't exist
if [ ! -f "${ENV_SCRIPT}" ]; then
  echo "[init-env] Creating ${ENV_SCRIPT}..."
  cat > "${ENV_SCRIPT}" << 'EOF'
#!/bin/bash
# Dev Tools Environment Configuration
# Auto-generated by dev-toolchain install scripts

EOF
  chmod +x "${ENV_SCRIPT}"
  echo "[init-env] Created ${ENV_SCRIPT}"
else
  echo "[init-env] ${ENV_SCRIPT} already exists"
fi

# Set custom hostname in prompt if CUSTOM_HOSTNAME env var is set
# This is needed in hostNetwork mode where pod hostname is the node hostname
# We use PS1 to display the desired hostname instead
if [ -n "${CUSTOM_HOSTNAME:-}" ]; then
  echo "[init-env] Configuring custom hostname: ${CUSTOM_HOSTNAME}"
  # Check if PS1 customization is already in the file
  if ! grep -qF "export CUSTOM_HOSTNAME=" "${ENV_SCRIPT}" 2>/dev/null; then
    cat >> "${ENV_SCRIPT}" << EOF

# Custom Hostname for Prompt
export CUSTOM_HOSTNAME="${CUSTOM_HOSTNAME}"
export PS1='\${debian_chroot:+(\$debian_chroot)}\u@\${CUSTOM_HOSTNAME}:\w\$ '
EOF
    echo "[init-env] Added CUSTOM_HOSTNAME to env script"
  else
    echo "[init-env] CUSTOM_HOSTNAME already configured"
  fi
else
  echo "[init-env] CUSTOM_HOSTNAME not set, skipping hostname configuration"
fi

# Export DOCKER_HOST if set (from Kubernetes env vars)
if [ -n "${DOCKER_HOST:-}" ]; then
  echo "[init-env] Configuring DOCKER_HOST: ${DOCKER_HOST}"
  # Check if DOCKER_HOST is already in the file
  if ! grep -qF "export DOCKER_HOST=" "${ENV_SCRIPT}" 2>/dev/null; then
    cat >> "${ENV_SCRIPT}" << EOF

# Docker Client Configuration
export DOCKER_HOST="${DOCKER_HOST}"
EOF
    echo "[init-env] Added DOCKER_HOST to env script"
  else
    echo "[init-env] DOCKER_HOST already configured"
  fi
else
  echo "[init-env] DOCKER_HOST not set, skipping docker configuration"
fi

# Export Homebrew environment variables and PATH
# Only write to config file if HOMEBREW_PREFIX is not set in current environment
# This handles the case when /root is mounted from PVC and .bashrc is missing

echo "[init-env] Checking Homebrew environment variables..."
if [ -z "${HOMEBREW_PREFIX:-}" ]; then
  echo "[init-env] HOMEBREW_PREFIX not set in environment, writing to config file..."

  if ! grep -qF "# Homebrew Environment" "${ENV_SCRIPT}" 2>/dev/null; then
    cat >> "${ENV_SCRIPT}" << 'EOF'

# Homebrew Environment
# Fallback configuration when Dockerfile ENV is not available
export HOMEBREW_PREFIX="/home/linuxbrew/.linuxbrew"
export HOMEBREW_CELLAR="/home/linuxbrew/.linuxbrew/Cellar"
export HOMEBREW_REPOSITORY="/home/linuxbrew/.linuxbrew"
export HOMEBREW_ALLOW_ROOT=1
export HOMEBREW_NO_ENV_HINTS=1
export HOMEBREW_NO_AUTO_UPDATE=1
export HOMEBREW_NO_INSTALL_FROM_API=1

# Homebrew PATH (prepend to ensure priority)
export PATH="${HOMEBREW_PREFIX}/bin:${HOMEBREW_PREFIX}/sbin:${PATH}"
EOF
    echo "[init-env] Added Homebrew environment variables to env script"
    echo "[init-env]   HOMEBREW_PREFIX=/home/linuxbrew/.linuxbrew"
    echo "[init-env]   PATH includes Homebrew directories"
  else
    echo "[init-env] Homebrew environment already configured in file"
  fi
else
  echo "[init-env] HOMEBREW_PREFIX already set: ${HOMEBREW_PREFIX}"
  echo "[init-env] Skipping Homebrew config (Dockerfile ENV is active)"
fi

# Display final env script content for debugging
echo "[init-env] Final ${ENV_SCRIPT} content:"
cat "${ENV_SCRIPT}"
echo "[init-env] Environment initialization completed successfully"
